{"ast":null,"code":"function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n/* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  } // Vue.extend constructor export interop.\n\n  var options = typeof script === 'function' ? script.options : script; // render functions\n\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true; // functional template\n\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  } // scopedId\n\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n  var hook;\n  if (moduleIdentifier) {\n    // server build\n    hook = function hook(context) {\n      // 2.3 injection\n      context = context ||\n      // cached call\n      this.$vnode && this.$vnode.ssrContext ||\n      // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      } // inject component styles\n\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      } // register component module identifier for async chunk inference\n\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    }; // used by ssr in case component is cached and beforeCreate\n    // never gets called\n\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function () {\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      var originalRender = options.render;\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n  return script;\n}\nvar normalizeComponent_1 = normalizeComponent;\nvar use = function use(plugin) {\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n  }\n};\nvar registerComponent = function registerComponent(Vue, component) {\n  Vue.component(component.name, component);\n};\nvar registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {\n  if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {};\n  Vue.prototype.$buefy[property] = component;\n};\nexport { normalizeComponent_1 as _, registerComponentProgrammatic as a, registerComponent as r, use as u };","map":{"version":3,"names":["normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","render","staticRenderFns","_compiled","functional","_scopeId","hook","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","renderWithStyleInjection","h","existing","beforeCreate","concat","normalizeComponent_1","use","plugin","window","Vue","registerComponent","component","name","registerComponentProgrammatic","property","prototype","$buefy","_","a","r","u"],"sources":["/home/markus/dev/org.eclipse.sensinact.gateway/prototype/webclient/node_modules/buefy/dist/esm/chunk-cca88db8.js"],"sourcesContent":["function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n/* server only */\n, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  } // Vue.extend constructor export interop.\n\n\n  var options = typeof script === 'function' ? script.options : script; // render functions\n\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true; // functional template\n\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  } // scopedId\n\n\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n\n  var hook;\n\n  if (moduleIdentifier) {\n    // server build\n    hook = function hook(context) {\n      // 2.3 injection\n      context = context || // cached call\n      this.$vnode && this.$vnode.ssrContext || // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      } // inject component styles\n\n\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      } // register component module identifier for async chunk inference\n\n\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    }; // used by ssr in case component is cached and beforeCreate\n    // never gets called\n\n\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function () {\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      var originalRender = options.render;\n\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n\n  return script;\n}\n\nvar normalizeComponent_1 = normalizeComponent;\n\nvar use = function use(plugin) {\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n  }\n};\nvar registerComponent = function registerComponent(Vue, component) {\n  Vue.component(component.name, component);\n};\nvar registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {\n  if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {};\n  Vue.prototype.$buefy[property] = component;\n};\n\nexport { normalizeComponent_1 as _, registerComponentProgrammatic as a, registerComponent as r, use as u };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}